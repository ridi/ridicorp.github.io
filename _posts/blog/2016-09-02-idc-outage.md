---
layout: blog
category: blog
title: "리디북스 서비스 장애 복구 후기"
description: "데이터센터의 장애를 통해 겪은 서비스중단 및 복구 후기"
header-img: "img/blog/bg-11.jpg"
date: 2016-09-02
author: namenu
type: engineering
published: true
---

지난 8월 26일에는 약 21분간 리디북스 서비스 전체가 중단되는 장애가 있었습니다.

사실 서버 스택 일부에만 영향을 주는 장애는 눈에 잘 띄지 않지만 꽤 흔하게 발생하는 일입니다.
기기 1대당 외부적인 요인으로 인한 장애가 평균 2년에 1번 발생한다고 가정하면,
서버가 100대 있을 때는 대략 1주일에 1번꼴로 장애가 발생하는 셈입니다.

이런 형태의 장애는 서버 스택의 한 곳에서만 발생하므로, 이중화 혹은 클러스터링을 통해서 극복하곤 합니다.
또한 원인이 명확하므로 해당 기술에 대한 이해도가 높다면 비교적 빠른 시간 내에 복구가 가능합니다.

그러나 이번에 리디북스가 경험한 장애는 달랐습니다.
현재 리디북스는 2개의 데이터센터와 클라우드에 인프라가 분산되어 있는데,
이 중에서 1차 데이터센터의 전원 공급에 문제가 생겨 특정 서버 랙에 있는 서버 17대가 동시에 내려간 것입니다.
즉, 소프트웨어나 머신의 물리적인 장애가 아닌, 데이터센터의 장애였습니다.
AWS로 비유를 하자면 가용 영역(Availability Zone)의 장애라고 할 수 있겠습니다.


## 원인에 대해

이번 장애의 근본적인 원인은 데이터센터가 전원을 정상적으로 공급해주지 못한 것입니다.
물론 데이터센터 혹은 클라우드 서비스(IaaS)는 고객사에게 전원과 네트워크를 안정적으로 제공해주어야 하는 의무가 있습니다.

하지만 이들 역시 천재지변이나 사람의 실수에 대한 대비가 100% 완벽할 수는 없습니다.
따라서 이러한 점을 사전에 고려하고 인프라를 설계하지 못한 것이 2차적인 원인입니다.

이번 계기를 통해 데이터센터 이중화를 계획하게 되었고,
사용 중인 클라우드 역시 지역(Region) 전체에 장애가 생길 경우에 대한 대비가 되어있지 않아,
이번 계기로 복제 계획(Geo-Replication)을 세우게 되었습니다.


## 구체적인 상황

당시 전원이 차단되어 강제 종료된 서버들은 아래와 같습니다.

* 데이터베이스 프록시 x 2
* 메인 리버스 프록시 x 1
* 읽기 분산용 MySQL 슬레이브 x 1
* 서점용 웹 서버 x 3
* 추천 알고리즘 API 서버 x 1
* 알림센터 API 서버 x 2
* 메인 스토리지 서버 x 2
* 출판 플랫폼용 데이터베이스 x 2
* 테스트 및 배치 작업용 서버 x 3

그림으로 표현해 보자면, 대략 아래와 같은 상황에서...
<br>

![before](https://i.imgur.com/Y5gUdVr.png){: data-action="zoom" }
<br>

아래와 같은 상황이 된 셈입니다.

![after](https://i.imgur.com/PgcWSNB.png){: data-action="zoom" }
<figcaption>서버 스택의 여러곳에 순간적으로 장애가 발생한 상황</figcaption>

공인 IP가 할당된 메인 프록시 서버 중 1대가 내려갔지만, 실제로는 아래와 같이 가상 IP로 구성을 한 상태였기 때문에
대기 중인(stand-by) 프록시가 동작하여 곧 서점에 장애 공지를 띄울 수 있었습니다.

![Image from DigitalOcean™](https://i.imgur.com/EOz8sIl.gif){: .center data-action="zoom" }
<figcaption><sub>[이미지 출처: <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-highly-available-haproxy-servers-with-keepalived-and-floating-ips-on-ubuntu-14-04">DigitalOcean™]</a></sub></figcaption>

<br>

## 공지 이후의 움직임

우리는 데이터센터의 복구 시점을 명확히 알 수 없어서 신규 구축(provisioning)을 시작함과 동시에, 서버들의 물리적인 위치 이동을 고려하고 있었습니다.
그러나 다행히 10분이 지난 시점에서 전원 문제는 해결되었고, 서버들은 순차적으로 부팅이 완료되었습니다.

일부 서버들은 부팅 과정에서 예상치 못한 지연이 발생하기도 하였지만, 모든 서버의 부팅이 완료된 이후에도 서비스는 완전히 정상으로 돌아오지 않았습니다.
당시 우리가 겪었던 문제와 해결책은 아래와 같습니다.


<br>

#### A. 읽기 분산용 MariaDB 슬레이브의 복제 지연(replication lag) 문제

슬레이브 서버의 부팅이 완료되자 데이터베이스 프록시(HAProxy)는 해당 서버를 정상으로 간주하여 라우팅 대상에 포함하게 되었고, 애플리케이션 서버들은 정상적으로 커넥션을 맺기 시작하였습니다.
하지만 해당 슬레이브는 수십 분간 마스터를 따라잡지 못한 상태였기 때문에 최신 데이터가 보여지지 않는 문제(stale data)가 있었습니다.
우리는 즉시 해당 슬레이브를 제거하였고 지연이 사라진 이후에 다시 서비스에 투입하였습니다.

<br>

#### B. 읽기 분산용 슬레이브의 웜업(warm-up) 문제

복제 지연은 사라졌지만 서버의 CPU 사용량이 크게 높은 상태가 한동안 유지되었고, 응답속도는 정상적인 슬레이브에 비해서 많이 느렸습니다.
왜냐하면 캐시가 비워진 상태에서 바로 서비스에 투입되어, 캐시 미스가 휘몰아치는 현상(cache stampede)이 발생하였기 때문입니다.
따라서 간단한 쿼리도 평소보다 오래 걸렸고, 그대로 둔다면 커넥션풀이 꽉 차는 현상이 발생할 것으로 예상되었습니다.

곧 우리는 HAProxy로 해당 서버의 가중치를 10%로 낮추어 인입되는 쿼리의 양을 조절하였으며 응답속도는 정상 수치로 돌아오게 되었습니다.
이후 스크립트를 작성하여 수동으로 캐시를 채워나감과 동시에 점차 가중치를 높여 처리량을 정상화하였습니다.

프로덕션에서 사용하는 서버는 `innodb_buffer_pool` 이 100G 이상으로 매우 크게 설정되어 있으며,
재시작 시 캐시가 날아가는 현상을 해결하기 위해 `innodb_blocking_buffer_pool_restore` 옵션을 적용하고 있습니다.
하지만 지금처럼 메모리를 덤프하지 못하고 비정상 종료가 된 상황에서는 해당되지 않았습니다.

<br>

#### C. 인메모리 데이터의 보존 문제

알림센터는 다양한 프로모션과 개인화된 정보를 전달해주는 공간입니다.
알림센터의 특징은 데이터의 영구 보존(persistency)이 필요하지 않고, 매일 수백만 건의 개인화된 메시지가 기록된다는 것입니다.
이러한 특징은 인-메모리 데이터베이스에 적합하므로 우리는 Redis를 마스터/슬레이브로 구성하여 저장소로 사용하고 있었습니다.

어떠한 이유로든 Redis를 재시작해야 할 경우가 생기면, 메모리 상의 데이터가 날아가는 것을 방지하기 위해 주기적으로 스냅샷을 남기고 있습니다만,
이번에는 로그가 마지막까지 기록되지 못한 상태에서 메모리의 데이터가 날아가 버렸습니다.

다행히 알림 발송과 관련된 메타정보는 모두 MariaDB에 기록하고 있으므로, 우리는 이를 기반으로 소실된 시점부터의 알림을 순차적으로 재발송할 수 있었습니다.
물론 모든 알림이 신규 상태로 간주되어 아이콘이 잘못 노출되는 문제가 있었지만, 고객님들은 너그럽게 이해해 주신 것 같습니다. 😅


---

## 그래서 앞으로는?

리디북스 DevOps 멤버들은 이번 데이터센터 장애를 통해 현재 인프라의 한계점을 실감하였고, 앞으로의 개선 방향에 대해 고민하게 되었습니다.

몇 가지를 정리하면 다음과 같습니다.

1. **랙 단위로 장애가 발생할 수 있음을 인지하고 대비하자.**
    - 같은 기능을 하는 서버를 하나의 랙이나 같은 가용 영역에 두지 말자.
  
2. **2차 데이터센터는 더 이상 옵션이 아닌 필수다.**
    - 낙뢰나 지진으로 인해 데이터센터에 문제가 생길 수도 있다.

3. **긴급하게 프로비저닝이 필요한 상황에 대비하자.**
    - 문서화가 되어 있더라도 경험이 없다면 동일한 구성에 많은 시간이 소요된다.
    - 모든 구성요소들에 대한 Ansible 스크립트를 작성하여두자.
    - 캐시 웜업 스크립트도 작성하여 두자.

4. **백엔드 구성요소들 간의 불필요한 의존 관계를 끊자.**
    - 단 한 줄의 코드라도 참조하고 있다면 이는 독립적인 것이 아니다.
    - 언제나 서비스 지향적인 설계를 추구하자.

5. **Uptime을 관리하자.**
    - 최대 180일을 기점으로 무조건 리부팅을 하자.
    - 재시작 과정에서 다양한 문제와 개선점이 발견될 것이다.
    - 커널 패치, 보안 패치를 할 수 있는 것은 덤이다.


아래와 같은 긍정적인 면도 발견하였습니다.

1. **장애 상황이 실시간으로 Slack 채널을 통해 전파되었음**
    - 진행 상황에 대해 모두가 동일한 수준으로 이해할 수 있었다.
    - 모니터링 연동(integration) 기능 때문에라도, Slack은 유료로 구매할만한 값어치가 충분하다.

2. **같은 기능을 하는 서버들이 다른 랙에 많이 분산되어 있었다.**
    - 인프라가 확장될 때마다 빈 공간에 필요한 서버를 추가했을 뿐이지만, 자연스럽게 물리적인 위치가 분산되는 효과가 있었다.
    - 이 외에도 특정 클러스터를 구성하는 노드들을 분산하여 배치시키자.

3. **서버별로 오너쉽이 부여되어 있어서 빠르게 복구가 된 점**
    - 여러 명의 백엔드 개발자들이 병렬적으로 복구를 진행할 수 있었다.



---

## 마지막으로

넷플릭스의 엔지니어들은 [무질서한 원숭이(Chaos Monkey)](https://github.com/Netflix/SimianArmy/wiki/Chaos-Monkey)라는 프로그램을 만들어서 운영한다고 합니다.
이 원숭이는 서비스 인스턴스들을 무작위로 중단시키는 역할을 합니다.
다소 황당하게 들리지만, 넷플릭스에는 일부 서비스에 장애가 발생하더라도 나머지 부분은 문제없이 운영되어야 한다는 원칙이 있으므로, 이를 수시로 시뮬레이션하는 과정을 통해 복구 능력을 높여둔다는 것입니다.

실제로 이렇게 급진적인 아이디어를 실천할 수 있는 회사는 매우 드물 것입니다.
하지만, 우리는 이번 계기를 통해 무질서한 원숭이의 필요성을 절감하였고, 이로 인해 서버를 주기적으로 리셋하는 정책을 만들게 되었으며 모든 단일 장애점(SPoF)에 대한 대비를 시작하게 되었습니다.

장애를 단순히 피해라고만 생각한다면, 서로를 비난하고 책임을 전가하는 상황이 펼쳐질 것입니다.
하지만 고객의 불편함과 맞바꾼 매우 비싼 경험이라고 생각한다면, 보다 튼튼하고 회복탄력적인 시스템을 갖추기 위해 노력하게 될 것입니다.
그러다 보면 언젠가는 데이터센터 전체에 문제가 생겨도 버틸 수 있는 모습으로 진화할 것이라고 생각합니다. 
